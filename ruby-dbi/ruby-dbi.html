<html><head><!-- this file was generated by troffcvt and tc2html -->
<title>Ruby DBI モジュールを使う</title>
<!-- title>Using the Ruby DBI Module</title -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>

<body>
<h1>
<center>
<!-- Using the Ruby DBI Module -->
Ruby DBI モジュールを使う<br>
</center>
</h1>
<center>
<p>
<i>Paul DuBois<br>
<a href="mailto:paul@kitebird.com">paul@kitebird.com<br>
</a></i>
訳者<br>
久保健洋<br>
<a href="mailto:kubo@jiubao.org">kubo@jiubao.org</a>
</p></center>
<center>
<p>
Original Document revision: 1.02<br>
Original Last update: 2003-05-27<br>
翻訳バージョン: 0.9.5
</p></center>

<h2>
<!-- Table of Contents -->
目次
</h2>
<!-- INSERT TOC HERE -->
<!-- TOC BEGIN -->
<ul>
<li>
<a href="#TOC_1">はじめに<!-- Introduction --></a>
</li><li>
<a href="#TOC_2">前準備<!-- Prerequisites --></a>
</li><li>
<a href="#TOC_3">インストール<!-- Installation --></a>
</li><li>
<a href="#TOC_4">単純なDBIスクリプト<!-- A Simple DBI Script --></a>
</li><li>
<a href="#TOC_5">問合せ処理<!-- Processing Queries --></a>
<ul>
<li>
<a href="#TOC_6">結果セットを返さない問合せ処理<!-- Processing Queries that Return No Result Set --></a>
</li><li>
<a href="#TOC_7">結果セットを返す問合せ処理<!-- Processing Queries that Return a Result Set --></a>
</li><li>
<a href="#TOC_8">クオート、プレースホルダー、パラメータ束縛<!-- Quoting, Placeholders, and Parameter Binding--></a>
</li><li>
<a href="#TOC_9">メタデータの問い合わせ<!-- Query Metadata --></a>
</li></ul>
</li><li>
<a href="#TOC_10">コードブロックつきのメソッド<!-- Methods That Take Code Blocks --></a>
</li><li>
<a href="#TOC_11">サーバ接続の補足<!-- More on Connecting to the Server--></a>
</li><li>
<a href="#TOC_12">エラー処理とデバッグ<!-- Error Handling and Debugging --></a>
</li><li>
<a href="#TOC_13">トランザクションサポート<!-- Transaction Support --></a>
</li><li>
<a href="#TOC_14">ドライバに特化した機能<!-- Accessing Driver-Specific Capabilities--></a>
</li><li>
<a href="#TOC_15">その他の便利な機能<!-- Other DBI Goodies--></a>
</li><li>
<a href="#TOC_16">参考情報<!-- Resources --></a>
</li></ul>
<!-- TOC END -->
<br>
<a name="TOC_1">
<h2>
<!-- Introduction -->
はじめに
</h2>
</a><br>
<p>
<!--
The Ruby DBI module provides a database-independent interface
for Ruby scripts similar to that of the Perl DBI module. This
article describes how to write Ruby DBI-based scripts. It is an
adjunct to and not a substitute for the DBI specification documents.
Be sure to read the specifications. For more information, see
the "Resources" section.-->

Ruby DBI を使うと、いろんな種類のデータベースを同じAPIでもってrubyから
アクセスすることができます。これは、Perl DBI と perl の関係と同じです。
この記事では Ruby DBI を使用したRubyスクリプトの書き方を説明します。こ
の文書は DBI 仕様書に説明を追加するものであって、DBI 仕様書そのものを
置き換えるものではありません。したがって、DBI 仕様書は必ず読んでくださ
い。本文書で足りない場合は、<a href="#TOC_16">「参考情報」</a>を参照し
てください。<br>

</p><p>
<!- The general architecture for Ruby DBI uses two layers: -->
Ruby DBI のアーキテクチャはおおまかに以下の２つの層(レイヤ)から成り立っ
ています。<br>
</p><ul>
<li>
<!--
The database interface (DBI) layer. This layer is database independent
and provides a set of common access methods that are used the
same way regardless of the type of database server with which
you're communicating.-->

1. DBI(データベースインターフェース)層。この層はデータベースに依存しな
い層です。使用するデータベースの種類がどんなものでも、この層のAPIを使
用すると同じ操作でもって接続することができます。<br>
</li><li>
<!--
The database driver (DBD) layer. This layer is database dependent;
different drivers provide access to different database engines.
There is one driver for MySQL, another for PostgreSQL, another
for InterBase, another for Oracle, and so forth. Each driver interprets
requests from the DBI layer and maps them onto requests appropriate
for a given type of database server.
-->

2. DBD(データベースドライバ)層。この層はデータベースに依存する層です。
データベースの種類毎に別々の種類のドライバが必要となります。例えば、
MySQL用、PostgreSQL用、InterBase用、Oracle用等々、様々なドライバがあり
ます。各ドライバはDBI層から渡ってくるリクエストを受けとり、対応するデー
タベースに適したリクエストへと変換します。<br>
</li></ul>
<!--
The examples in this article use the MySQL database driver, but
for many of them you should be able to substitute other drivers.
-->

この記事では MySQL データベースドライバを例にとります。しかしあなたの
使用するデータベースが MySQL でなくても、ほとんどのことは同様に使用す
ることができます。<br>
<a name="TOC_2">
<h2>
<!-- Prerequisites -->
前準備
</h2>
</a>
<p>
<!--
The Ruby DBI module includes the code that implements the general
DBI layer, as well as a set of DBD-level drivers. Many of these
drivers require that you have additional software installed. For
example, the database driver for MySQL is written in Ruby and
provides a binding to the Ruby MySQL module, which itself is written
in C and provides a binding to the MySQL C client API. This means
that if you want to write DBI scripts to access MySQL databases,
you'll need to have both the Ruby MySQL module and the C API installed.
For further information on the Ruby MySQL module, see the article
referenced in the "Resources" section. Here, I will
assume that the MySQL module is installed and available for use
by DBI.<br>
-->

Ruby DBI は汎用的なDBI層のコードと、DBDレベルの様々なドライバから成り
立っています。これらのドライバを使用するときにはほとんどの場合、それ用
のソフトウェアを追加でインストールする必要があります。例えば MySQL の
DBDドライバそのものは Ruby で書かれており、DBIから渡されたリクエストを
Ruby MySQL モジュールのリクエストへと変換して渡します。そして、Ruby
MySQL モジュールそのものは C で書かれており、DBDドライバから渡されたリ
クエストを MySQL の C クライアントライブラリへと変換して渡します。
つまり、DBI を使うスクリプトを書いて、MySQL データベースへと接続する場
合には、Ruby MySQL モジュールと C API との両方を追加インストールする必
要があります。Ruby MySQL モジュールについての情報は<a href="#TOC_16">
「参考情報」</a>に記載されている参考文献を見てください。ここでは MySQL
モジュールはすでにインストールされており、使用できる状態にあるとみなし
ます。<br>

<a name="TOC_3">
<h2>
<!-- Installation -->
インストール
</h2>
</a>
</p><p>
<!--
After you have satisfied the prerequisites described in the previous
section, you can install the Ruby DBI module, which may be obtained
from the following site:
-->

MySQL の C クライアントライブラリと Ruby MySQL モジュールの準備が終わっ
たら、Ruby DBI モジュールのインストールが可能となります。Ruby DBI モ
ジュールは以下のサイトから取得できます。<br>

</p><pre>   <a href="http://rubyforge.net/projects/ruby-dbi/">http://rubyforge.net/projects/ruby-dbi/</a>
</pre>
<!--
The DBI module is distributed as a compressed <i>tar</i> file,
which you should unpack after downloading it. For example, if
the current version is 0.0.19, the distribution file can be unpacked
using either of the following commands:
-->

DBIモジュールは圧縮されたtarファイルとして配布されているので、ダウン
ロードした後に展開する必要があります。例えば、現在のバージョンが 0.0.19
とすると、配布ファイルは以下のコマンドで展開されます。<br>
<pre>   % <b>tar zxf ruby-dbi-all-0.0.19.tar.gz</b>
   (訳者註: GNU tar の場合)
   % <b>gunzip &lt; ruby-dbi-all-0.0.19.tar.gz | tar xf -</b>
   (訳者註: 商用UNIXのOS附属の tar の場合)
</pre>
<!--
After unpacking the distribution, change location into its top-level
directory and configure it using the <i>setup.rb</i> script in
that directory. The most general configuration command looks like
this, with no arguments following the <tt>config</tt> argument:
-->
配布パッケージを展開したら、展開したファイルのトップディレクトリへ移動し、
そのディレクトリにある setup.rb スクリプトを使ってインストールするパッ
ケージの特定を行います。
一般的には、以下のように config 引数の後にはなにも引数をつけません。<br>
<pre>   % <b>ruby setup.rb config</b>
</pre>
<!--
That command configures the distribution to install all drivers
by default. To be more specific, provide a <i>--with</i> option
that lists the particular parts of the distribution you want to
use. For example, to configure only the main DBI module and the
MySQL DBD-level driver, issue the following command:<br>
-->
このように実行すると、デフォルトですべてのドライバがインストール対象と
なります。インストールするドライバを選択したい場合、--with オプションに
ドライバの名前を列挙します。例えば、DBI のメイン部分と MySQL の DBD レ
ベルのドライバのみをインストールするときは、次のコマンドを発行します。<br>
<pre>   % <b>ruby setup.rb config --with=dbi,dbd_mysql</b>
</pre>
<!--
After configuring the distribution, build and install it:<br>
-->
インストールパッケージの設定が終わったら、ビルドしてインストールします。<br>
<pre>   % <b>ruby setup.rb setup</b>
   % <b>ruby setup.rb install</b>
</pre>
<!--
You may need to run the installation command as <tt>root</tt>.<br>
-->
このコマンドは root で実行しなければならない場合があります。<br>
<p>
<!--
The rest of this article uses the following notational conventions:<br>
-->
この記事では以降、以下の表記を慣習として使用します。
</p><ul>
<li>
<!--
"DBI module" refers collectively to the DBI layer as
well as the DBD-level drivers, unless context indicates that only
the database independent layer is meant.<br>
-->
"DBI モジュール" はデータベース独立のレイヤを意味すると文脈上示されな
いかぎり、DBI層とDBD層のドライバをまとめて指します。<br>
</li><li>
<!--
"<tt>DBD::Mysql</tt>" refers to the MySQL-specific database
driver for DBI.<br>
-->
"<tt>DBD::Mysql</tt>" はDBIのMySQL用データベースドライバを指します。<br>
</li><li>
<!--
"Ruby MySQL module" refers to the module on which <tt>DBD::Mysql</tt>
is built.<br>
-->
"Ruby MySQL モジュール" は<tt>DBD::Mysql</tt>の土台となるCで書かれた
モジュールを指します。
</li></ul>
<a name="TOC_4">
<h2>
<!--
A Simple DBI Script
-->
単純なDBIスクリプト
</h2>
</a>
<p>
<!--
With the Ruby DBI module installed, you should be able to access
your MySQL server from within Ruby programs. Assume for purposes
of this article that the server is running on the local host and
that you have access to a database named <tt>test</tt> by connecting
using an account that has a username and password of <tt>testuser</tt>
and <tt>testpass</tt>. You can set up this account by using the
<i>mysql</i> program to connect to the server as the MySQL <tt>root</tt>
user and issuing the following statement:<br>
-->
Ruby DBI モジュールがインストールされているなら、Rubyプログラムから
MySQL サーバへ接続できるようになっています。
この記事では、サーバはローカルホストで動いており、test という名前のデー
タベースへ testuser、testpass というユーザ名、パスワードで接続できると
みなします。testuser を作成するには、MySQL の root ユーザでサーバへ接
続して次の文を発行してください。<br>
</p><pre>   mysql&gt; <b>GRANT ALL ON test.* TO 'testuser'@'localhost' IDENTIFIED BY 'testpass';</b>
</pre>
<!--
If the <tt>test</tt> database does not exist, create it with this
statement:<br>
-->
test データベースがない場合は、次の文を発行してデータベースを作成して
ください。<br>
<pre>   mysql&gt; <b>CREATE DATABASE test;</b>
</pre>
<!--
If you want to use a different server host, username, password,
or database name, just substitute the appropriate values in each
of the scripts discussed in the remainder of this article.<br>
-->
別のサーバホスト、ユーザ名、パスワード、データベース名を使用したい場合
は、この記事の以降のスクリプトにでてくる値を適切な値に置き換えてくださ
い。
<p>
<!--
The following script, <i>simple.rb</i>, is a short DBI program
that just connects to the server, retrieves and displays the server
version, and disconnects. You can download the script from the
link listed in the "Resources" section, or use a text
editor to create it directly:<br>
-->
次のスクリプト<i>simple.rb</i>は、サーバへ接続して、サーバのバージョン
を取得して、表示して、接続を切るだけの短いDBIプログラムです。このスク
リプトは<a href="#TOC_16">「参考情報」</a>のリンクからダウンロードでき
ます。テキストエディタで直接作成してもかまいません。
</p><pre>   # simple.rb - Ruby DBI を使用した簡単なMySQLスクリプト

   require "dbi"

   begin
       # MySQLサーバへ接続
       dbh = DBI.connect("dbi:Mysql:test:localhost", "testuser", "testpass")
       # サーババージョンの文字列を取得して、表示する。
       row = dbh.select_one("SELECT VERSION()")
       puts "Server version: " + row[0]
   rescue DBI::DatabaseError =&gt; e
       puts "An error occurred"
       puts "Error code: #{e.err}"
       puts "Error message: #{e.errstr}"
   ensure
       # サーバから切断
       dbh.disconnect if dbh
   end

</pre>
<!--
The <i>simple.rb</i> script provides a very basic general overview
of DBI concepts. The immediately following discussion explains
how it works, and later sections show other examples that provide
additional detail on specific aspects of DBI programming.<br>
-->
<i>simple.rb</i>スクリプトからはDBIの基本的なコンセプトが読み取れます。
このセクションの残りではDBIがどのように働くかを説明し、次のセクション
からDBIプログラミング特有の側面について例を出しつつ詳細に記述していき
ます。
<p>
<!--
<i>simple.rb</i> begins with a <tt>require</tt> line that pulls
in the DBI module; without that line, DBI methods will fail. The
rest of the script is placed within a <tt>begin/rescue/ensure</tt>
construct:<br>
-->
<i>simple.rb</i>はDBIモジュール要求する<tt>require</tt>の行から始ま
ります。この行がないと、DBI メソッド呼び出しが失敗します。スクリプトの
残り部分は<tt>begin/rescue/ensure</tt>の中に置いてあります。
</p><ul>
<li>
<!--
The <tt>begin</tt> block handles all the database processing.<br>
-->
<tt>begin</tt>ブロックではデータベース処理をすべてあつかいます。
</li><li>
<!--
The <tt>rescue</tt> block handles any exceptions that occur; it
obtains and displays error information.<br>
-->
<tt>rescue</tt>ブロックでは例外が起こったときの処理をあつかい、エラー
情報を取得して画面に表示します。
</li><li>
<!--
The <tt>ensure</tt> block make sure that the script closes any
open connection to the database server.<br>
-->
<tt>ensure</tt>ブロックではデータベースサーバへの接続がどんな状態でも
確実に閉じられるようにします。
</li></ul>
<!--
The <tt>connect</tt> method establishes a connection to the database
server and returns a database handle to use for further communication
with the server. The first argument is a data source name (DSN)
that indicates the driver name (which for MySQL is <tt>Mysql</tt>),
the default database name, and the hostname of the server. The
second and third arguments are the username and password of the
MySQL account to use. There are other ways to write DSN values;
these are covered later in the section "More on Connecting
to the Server."<br>
-->
<tt>connect</tt>メソッドはデータベースサーバへの接続を確立し、サーバと
の通信に使用するデータベースハンドルを戻します。第一引数には、ドライバ
名(MySQLの場合は<tt>Mysql</tt>)、デフォルトのデータベース名、サーバの
ホスト名を示すデータソース名(DSN, data source name)をわたします。
第二引数と第三引数は MySQL アカウントのユーザ名とパスワードです。DSNの
値を書く方法は他にもあります。他の方法に関しては後のセクションの<a
href="#TOC_11">「サーバ接続の補足」</a>であつかわれます。
<p>
<!--
<i>simple.rb</i> uses the database handle to call <tt>select_one</tt>,
a method that sends a query to the server and returns the first
row of the result as an array. The <tt>SELECT</tt> <tt>VERSION()</tt>
query returns a single value, so the version string is available
as <tt>row[0]</tt>, the first (and only) element of the array.
When you run the script, the result looks something like this:<br>
-->
<i>simple.rb</i>はデータベースハンドルを使って<tt>select_one</tt>メソッ
ドを呼んでいます。このメソッドは、問い合わせをサーバへ送り、結果列の最
初の行を配列として戻すメソッドです。問い合わせ<tt>SELECT
VERSION()</tt>は値をひとつ戻します。したがって、バージョン文字列は
<tt>row[0]</tt>として利用できます。これは配列の最初のそしてただひとつ
の項目です。スクリプトを走らせると、結果はこのように表示されます。
</p><pre>   % <b>ruby simple.rb</b>
   Server version: 4.0.13-log
</pre>
<!--
Errors cause exceptions to be raised. Various kinds of exceptions
can occur, but most of those related to database operations cause
a <tt>DatabaseError</tt> exception to be raised. Objects of this
exception class have <tt>err</tt> and <tt>errstr</tt> attributes
that represent the error number and descriptive error message.
<i>simple.rb</i> obtains and prints these values for database
exceptions, and ignores other types of exceptions. (Should another
exception occur, it will be passed back to Ruby itself for processing.)<br>
-->
エラーが起こると例外が上ります。様々な種類の例外が起こり得ます。
しかし、データベースの操作に関するエラーのほとんどは
<tt>DatabaseError</tt>例外を引き起こします。この例外のオブジェクトは
<tt>err</tt>と<tt>errstr</tt>の属性を持っていて、エラー番号とエラーの
内容を記述したメッセージを意味します。
<i>simple.rb</i>はデータベース例外に関連するこれらの値を取得して出力
し、その他の種類の例外は無視します。(本来ならば、rescue ブロック内で
例外を作成し、呼び出し元のコードにわたして処理するべきです。)
<p>
<!--
<i>simple.rb</i> terminates the connection to the server by invoking
the <tt>disconnect</tt> method. This is done in an <tt>ensure</tt>
block to make sure that connection termination occurs even if
an error occurs during query processing.<br>
-->
<i>simple.rb</i>は<tt>disconnect</tt>メソッドを呼んでサーバへの接続を
切ります。切断は<tt>ensure</tt>ブロックで行い、問い合せを処理している
最中にエラーが起きても接続が確実に切られるようにします。
<a name="TOC_5">
<h2>
<!--
Processing Queries
-->
問合せ処理
</h2>
</a><br>
</p><p>
<!--
Ruby DBI provides many ways to execute statements. This section
discusses a few of them, but there are others.<br>
-->
RUby DBI を用いてSQL文を実行する方法はたくさんあります。このセクション
ででそのうちの何種類かを使用します。ここで記述されなかった方法について
はDBI仕様書を参照してください。
</p><p>
<!--
Many of the examples use a table named <tt>people</tt> that has
the following structure:<br>
-->
本文書で使用するサンプルスクリプトは、大抵の場合、<tt>people</tt>とい
う名前のテーブルを使用します。このテーブルは以下の構造をしています。
</p><pre>   CREATE TABLE people
   (
       id INT UNSIGNED NOT NULL AUTO_INCREMENT,    # ID番号
       name CHAR(20) NOT NULL,                     # 名前
       height FLOAT,                               # 身長(インチ単位)
       PRIMARY KEY (id)
   );
</pre>
<a name="TOC_6">
<h3>
<!--
Processing Queries that Return No Result Set
-->
結果セットを返さない問合せ処理
</h3>
</a>
<p>
<!--
Statements that do not return rows may be issued by invoking the
<tt>do</tt> database handle method. This method takes a query
string argument and returns a count of the number of rows affected
by the query. The following example uses <tt>do</tt> several times
to create the <tt>people</tt> table and populate it with a small
data set:<br>
-->
行を返さないSQL文は、データベースハンドルの<tt>do</tt>メソッドでもって
実行できます。このメソッドは問い合せ文字列１つを引数にとり、問い合わせ
の実行で影響の受けた行を戻します。次の例は<tt>do</tt>を何回も使用して、
<tt>people</tt>テーブルを作成し小さなテーブルデータを挿入します。

</p><pre>   dbh.do("DROP TABLE IF EXISTS people")
   dbh.do("CREATE TABLE people (
           id INT UNSIGNED NOT NULL AUTO_INCREMENT,
           PRIMARY KEY (id),
           name CHAR(20) NOT NULL,
           height FLOAT)")
   rows = dbh.do("INSERT INTO people (name,height)
           VALUES('Wanda',62.5),('Robert',75),('Phillip',71.5),('Sarah',68)")
   printf "%d rows were inserted\n", rows
</pre>
<!--
Note that for the <tt>INSERT</tt> statement, the script obtains
the row count and displays it to indicate how many rows were added
to the table.<br>
-->
<tt>INSERT</tt>文の実行箇所を見てください。スクリプト内でどれだけの数
の行がテーブルに追加されたか取得し、画面に表示しています。
<a name="TOC_7">
<h3>
<!--
Processing Queries that Return a Result Set
-->
結果セットを返す問合せ処理
</h3>
</a><br>
<p>
<!--
Statements such as <tt>SELECT</tt> or <tt>SHOW</tt> return rows.
To process such a statement, send it to the server for execution,
retrieve any rows in the result set that it generates, and dispose
of the result set.<br>
-->
<tt>SELECT</tt>や<tt>SHOW</tt>といったSQL文は行を戻します。このような
SQL文を処理するには、SQL文をサーバへ送信して実行し、生成された結果セッ
トに含まれる行を取得して、最後に結果セットを破棄する必要があります。
</p><p>
<!--
One way to do this is to call <tt>prepare</tt> to generate a statement
handle. Use that handle to execute the statement and fetch its
results, and then free the result set:<br>
-->
実行方法は何種類もありますが、ここでは<tt>prepare</tt>メソッドを呼んで
文ハンドルを生成し、このハンドルを使用して文を実行し、実行結果を得て、
結果セットを解放する方法を使用します。
<!--
</p><pre>   sth = dbh.prepare(<i>statement</i>)
   sth.execute
<i>   ... fetch rows ...</i>
   sth.finish
</pre>
-->
</p><pre>   sth = dbh.prepare(<i>SQL文</i>)
   sth.execute
<i>   ... 行を取得 ...</i>
   sth.finish
</pre>
<!--
It's also possible to pass the statement directly to <tt>execute</tt>
and skip the call to <tt>prepare</tt>:<br>
-->
SQL文を直接<tt>execute</tt>にわたして、<tt>prepare</tt>の呼び出しをス
キップする方法もあります。
<!--
<pre>   sth = dbh.execute(<i>statement</i>)
<i>   ... fetch rows ...</i>
   sth.finish
</pre>
-->
<pre>   sth = dbh.execute(<i>SQL文</i>)
<i>   ... 行を取得 ...</i>
   sth.finish
</pre>
<!--
There are many ways to fetch results after executing a statement.
You can call <tt>fetch</tt> as a standalone method in a loop until
it returns <tt>nil</tt>:<br>
-->
SQL文を実行した後に結果セットから検索結果を得る方法は何種類もあります。
そのうちの一つとして、<tt>fetch</tt>をブロックなしで呼び出しで、
<tt>nil</tt>が戻るまでループする方法があります。

<pre>   sth = dbh.execute("SELECT * FROM people")
   while row = sth.fetch do
       printf "ID: %d, Name: %s, Height: %.1f\n", row[0], row[1], row[2]
   end
   sth.finish
</pre>
<!--
<tt>fetch</tt> can also be used as an iterator, in which case
it is the same as <tt>each</tt>. These two row-fetching loops
are equivalent:<br>
-->
<tt>fetch</tt>はイテレータとして使う方法もあります。これは
<tt>each</tt>をイテレータとして呼んだときと同じです。<tt>fetch</tt>も
<tt>each</tt>も等価です。
<pre>   sth = dbh.execute("SELECT * FROM people")
   sth.fetch do |row|
       printf "ID: %d, Name: %s, Height: %.1f\n", row[0], row[1], row[2]
   end
   sth.finish

   sth = dbh.execute("SELECT * FROM people")
   sth.each do |row|
       printf "ID: %d, Name: %s, Height: %.1f\n", row[0], row[1], row[2]
   end
   sth.finish
</pre>
<!--
<tt>fetch</tt> and <tt>each</tt> produce <tt>DBI::Row</tt> objects,
which have methods for accessing their contents:<br>
-->
<tt>fetch</tt>と<tt>each</tt>は<tt>DBI::Row</tt>オブジェクトを生成しま
す。行の中身をアクセスするには、DBI::Rowオブジェクトのメソッドを使用し
ます。
<ul>
<li>
<!--
You can use a row object with <tt>by_index</tt> or <tt>by_field</tt>
to access column values by number or by name:<br>
-->
行オブジェクト(DBI::Row)のデータを数字や名前でカラムのデータにアクセス
するには、<tt>by_index</tt>や<tt>by_field</tt>を使用します。
<pre>   val = row.by_index(2)
   val = row.by_field("height")
</pre>
</li><li>
<!--
Column values also can be accessed by index or name using array
notation:<br>
-->
カラムの値へのインデックスや名前でのアクセスは、配列の表記法でも行うこ
とができます。
<pre>   val = row[2]
   val = row["height"]
</pre>
</li><li>
<!--
An iterator method, <tt>each_with_name</tt>, produces each column
value along with the column name:<br>
-->
イテレータのメソッド<tt>each_with_name</tt>はカラムの名前といっしょに
カラムの値を取り出します。
<pre>   sth = dbh.execute("SELECT * FROM people")
   sth.each do |row|
       row.each_with_name do |val, name|
           printf "%s: %s, ", name, val.to_s
       end
       print "\n"
   end
   sth.finish
</pre>
</li><li>
<!--
<tt>DBI::Row</tt> objects also have a <tt>column_names</tt> method
that returns an array containing the names for each column. <tt>field_names</tt>
is an alias for <tt>column_names</tt>.<br>
-->
<tt>DBI::Row</tt>オブジェクトには<tt>column_names</tt>メソッドもありま
す。このメソッドは各カラムの名前からなる配列を戻します。
<tt>field_names</tt>は<tt>column_names</tt>の別名です。
</li></ul>
<!--
Other row-fetching methods include <tt>fetch_array</tt> and <tt>fetch_hash</tt>.
These do not return <tt>DBI::Row</tt> objects. Instead, they return
the next row as an array or a hash, or <tt>nil</tt> if there are
no more rows. Hashes returned by <tt>fetch_hash</tt> are keyed
by column name with column values as hash values. Either method
may be invoked in standalone fashion or as an iterator. The following
examples demonstrate this for <tt>fetch_hash</tt>:<br>
-->
結果セットより検索結果を取得するメソッドは他に、<tt>fetch_array</tt>と<tt>fetch_hash</tt>
があります。このメソッドは<tt>DBI::Row</tt>オブジェクトを戻しません。
代りに検索結果を配列やハッシュとして戻し、それ以上行がないときはnilを戻
します。<tt>fetch_hash</tt>で戻るハッシュはカラム名がキーでカラムの値
が値となっています。どちらのメソッドもブロックなしでも、イテレータとし
ても呼ぶことができます。次は<tt>fetch_hash</tt>を使用した例です。
<pre>   sth = dbh.execute("SELECT * FROM people")
   while row = sth.fetch_hash do
       printf "ID: %d, Name: %s, Height: %.1f\n",
               row["id"], row["name"], row["height"]
   end
   sth.finish

   sth = dbh.execute("SELECT * FROM people")
   sth.fetch_hash do |row|
       printf "ID: %d, Name: %s, Height: %.1f\n",
               row["id"], row["name"], row["height"]
   end
   sth.finish
</pre>
データベースハンドルのメソッドを利用すると、execute-fetch-finishの一連の
操作を個々に実行しなくても良くなります。次のメソッドはこれらの仕事を一
度に行い、結果を戻します。
<pre>   row = dbh.select_one(<i>statement</i>)
   rows = dbh.select_all(<i>statement</i>)
</pre>
<!--
<tt>select_one</tt> executes a query and returns the first row
as an array, or <tt>nil</tt> if the query returns no rows. <tt>select_all</tt>
returns an array of <tt>DBI::Row</tt> objects. (You can access
the contents of these objects as discussed earlier.) The array
will be empty if the query returns no rows.<br>
-->
<tt>select_one</tt>は問合せを実行して最初の一行を配列として戻します。
問合せが一行も返さないときは<tt>nil</tt>を戻します。
<tt>select_all</tt>は<tt>DBI::Row</tt>オブジェクトの配列を戻します。
（このオブジェクトの中身は以前説明した方法にアクセスできます。）
問合せが一行も返さないときは空の配列となります。
<p>
<!--
The MySQL driver examines the metadata for the result set and
uses it to coerce row values to the corresponding Ruby data type.
(This means, for example,, that <tt>id</tt>, <tt>name</tt>, and
<tt>height</tt> values retrieved from the <tt>people</tt> table
will be returned as <tt>Fixnum</tt>, <tt>String</tt>, and <tt>Float</tt>
objects.) However, be aware that if a column value is <tt>NULL</tt>,
it will be represented as <tt>nil</tt> in the result set and its
type will be <tt>NilClass</tt>. Also note that this coercion behavior
does not appear to be mandated by the DBI specification and may
not be performed by all drivers.<br>
-->
MySQLドライバは結果セットのメタデータを調べて行の値を対応するRubyのデー
タタイプへ変換します。（言い換えると、例えば、<tt>people</tt>
テーブルから取り出された<tt>id</tt>、<tt>name</tt>、<tt>height</tt>の
値が<tt>Fixnum</tt>、<tt>String</tt>、<tt>Float</tt>のオブジェクトとし
て戻されるということです。） しかし、カラムの値が<tt>NULL</tt>の場合は
注意してください。この場合は、NULL値は結果セットでは<tt>nil</tt>として
表現され、その種類は<tt>NilClass</tt>となります。また、どのような型に
変換するかはDBI仕様書では規定されておらず、DBDドライバによって変換先が
異なる場合があります。
<a name="TOC_8">
<h3>
<!--
Quoting, Placeholders, and Parameter Binding
-->
クオート、プレースホルダー、パラメータ束縛
</h3>
</a>
</p><p>
<!--
Ruby DBI provides a placeholder mechanism that allows you to avoid
including data values literally in a query string. Instead, you
use special markers within the statement to indicate where the
data values go. When you execute the statement, you provide values
to be bound to the placeholders. DBI substitutes the values into
the statement where the placeholders appear, performing any quoting
of string values and escaping of special characters as necessary.
This makes it easy to construct statements without having to know
whether or not the values contain special characters, and without
having to do any quote processing yourself. The placeholder mechanism
also properly handles <tt>NULL</tt> values; just provide <tt>nil</tt>
as a data value and it will be placed into the statement as an
unquoted <tt>NULL</tt> value.<br>
-->
Ruby DBI にはプレースホルダー機構があり、問合せ文字列のデータの
値を直接取り込まなくても良いようになっています。代わりにSQL文の中に特
別な印をつけて、データの値が入る場所を示します。SQL文を実行するときに
は、プレースホルダーにバインドする値を与えておきます。DBIはプレースホ
ルダーの現れる場所のSQL文をバインドした値に置き換えます。このとき文字
列の値はクオートで囲って、必要なら特殊文字をエスケープします。これを使
うと、与えようとする文字に特殊文字が含まれているかどうか気にせずに、ま
た、自身でクオートで囲うことなしに簡単にSQL文を組み立てることができま
す。プレースホルダー機構は<tt>NULL</tt>値も適切にあつかいます。
<tt>nil</tt>をデータとして与えるだけで、クオートされていない
<tt>NULL</tt>値としてSQL文中に置かれます。
</p><p>
<!--
The following example illustrates how this works. Suppose you
want to add a new row to the <tt>people</tt> table for someone
named Na'il (a name that includes a quote), who is 76 inches tall.
To indicate where the data values go in the <tt>INSERT</tt> statement,
use '<tt>?</tt>' placeholder markers (without any surrounding
quotes), and provide the data values as additional arguments to
<tt>do</tt> following the statement:<br>
-->
次の例はこれがどのように働くかを説明します。例として、クオートを含む
Na'ilという名前で身長が76インチの人を<tt>people</tt>テーブルにに追加す
ると想定しましょう。まず、データが<tt>INSERT</tt>文のどこに入るかを示
すために、プレースホルダーの印'<tt>?</tt>'をシングルクオートなしで使
い、次いで、<tt>do</tt>の引数にSQL文につづけて、追加の引数としてデータ
を与えます。
</p><pre>   dbh.do("INSERT INTO people (id, name, height) VALUES(?, ?, ?)",
           nil, "Na'il", 76)
</pre>
<!--
The resulting statement produced by <tt>do</tt> and sent to the
server looks like this:<br>
-->
<tt>do</tt>により生成されてサーバへ送られる最終的なSQL文は次のようにな
ります。
<pre>   INSERT INTO people (id,name,height) VALUES(NULL,'Na\'il',76)
</pre>
<!--
If you plan to execute a statement multiple times, you can prepare
it first to obtain a statement handle, then execute it with the
data values as arguments. Assume that a data file named <i>people.txt</i>
contains lines of tab-delimited name/height pairs to be inserted
into the <tt>people</tt> table. The following example reads the
file to obtain row data, executing a prepared <tt>INSERT</tt>
statement once for each row:<br>
-->
SQLを何回も実行しようと考えている場合は、文ハンドルを得るために
<tt>prepare</tt>で準備してから、<tt>execute</tt>でデータを引数として与
えながら実行することができます。
<i>people.txt</i>という名のデータファイルに、<tt>people</tt>テーブルに挿
入する名前/身長のペアがタブ区切りで行毎にはいっていると仮定しましょう。
次の例はファイルを呼んで一行のデータを得て、前もって準備した
<tt>INSERT</tt>文を各行ごとに実行します。
<!--
<pre>   # prepare statement for use within insert loop
   sth = dbh.prepare("INSERT INTO people (id, name, height) VALUES(?, ?, ?)")

   # read each line from file, split into values, and insert into database
   f = File.open("people.txt", "r")
   f.each_line do |line|
       name, height = line.chomp.split("\t")
       sth.execute(nil, name, height)
   end
   f.close
</pre>
-->
<pre>   # 挿入ループで使用する文ハンドルを用意する。
   sth = dbh.prepare("INSERT INTO people (id, name, height) VALUES(?, ?, ?)")

   # ファイルから一行づつ読んで、値に分けて、データベースへ挿入する。
   f = File.open("people.txt", "r")
   f.each_line do |line|
       name, height = line.chomp.split("\t")
       sth.execute(nil, name, height)
   end
   f.close
</pre>
<!--
Preparing a statement first, then executing it multiple times
within a loop is more efficient than invoking <tt>do</tt> each
time through the loop (which in effect calls both <tt>prepare</tt>
and <tt>execute</tt> for each iteration). The difference is most
significant for database engines that prepare a query execution
plan and reuse it for each call to <tt>execute</tt>. MySQL doesn't
do this; Oracle does.<br>
-->

SQL文を prepare した後にループ内で何回も実行したほうが、ループ毎に
<tt>do</tt>を呼び出す(繰り返し毎に<tt>prepare</tt>と<tt>execute</tt>の
両方を呼ぶのと同等)よりも効率的です。問い合わせ実行計画を準備して、
<tt>execute</tt>の呼び出し毎に実行計画を再利用するデータベースの場合、
これは重大な効率上の差異となります。MySQLは実行計画を再利用はできませ
んが、Oracleは再利用します。
<p>
<!--
To use placeholders for <tt>SELECT</tt> statements, the proper
strategy depends on whether you prepare the statement first:<br>
-->
<tt>SELECT</tt>文にプレースホルダーを使う場合、SQL文を最初の準備するか
にするかどうかで適切な方法がかわります。
</p><ul>
<li>
<!--
If you invoke <tt>prepare</tt> to obtain a statement handle, use
that handle to call <tt>execute</tt> and pass it the data values
to be bound to the placeholders:<br>
-->
<tt>prepare</tt>メソッドで文ハンドルを作成した場合、文ハンドルに対し
て<tt>execute</tt>を呼んで、プレースホルダーにバインドするデータをわた
します。

<pre>   sth = dbh.prepare("SELECT * FROM people WHERE name = ?")
   sth.execute("Na'il")
   sth.fetch do |row|
       printf "ID: %d, Name: %s, Height: %.1f\n", row[0], row[1], row[2]
   end
   sth.finish
</pre>
</li><li>
<!--
If you don't use <tt>prepare</tt>, the first argument to <tt>execute</tt>
is the statement and the following arguments are the data values:<br>
-->
<tt>prepare</tt>を使わない場合は、<tt>execute</tt>の第一引数はSQL文に
して、続けてプレースホルダーにバインドするデータをわたします。
<pre>   sth = dbh.execute("SELECT * FROM people WHERE name = ?", "Na'il")
   sth.fetch do |row|
       printf "ID: %d, Name: %s, Height: %.1f\n", row[0], row[1], row[2]
   end
   sth.finish
</pre>
</li></ul>
<!--
Other drivers may allow or require that you represent placeholders
differently. For example, you may be able to write placeholders
as <tt>:</tt><tt><i>name</i></tt> or <tt>:</tt><tt><i>n</i></tt>
to specify them in named or numbered form.<br>
-->
他のドライバは別の形式のプレースホルダーでも受け付けるかもしれません。
また、別の形式でないと受け付けないかもしれません。例えば、プレースホル
ダーを <tt>:name</tt> や <tt>:n</tt> として名前付きや数値付きの形式で
書けるかもしれません。
<p>
<!--
The <tt>quote</tt> method performs quoting and escaping of a data
value and returns the result. This can be useful for constructing
statements to be executed by other programs. For example, if you
want to read the data file <i>people.txt</i> and convert it to
a set of <tt>INSERT</tt> statements that can be processed by a
program such as the <i>mysql</i> command-line client, do this:<br>
-->
<tt>quote</tt>メソッドはデータ値をクオートで囲い、特殊文字をエスケープ
して、結果を戻します。これは他のプログラムで実行するSQL文を組み立てる
のに便利です。例えば、データファイル<i>people.txt</i>を読んで、
<tt>INSERT</tt>文のかたまりに変形して、コマンドラインクライアントの
<i>mysql</i>といったプログラムで処理させる場合、次のようにします。
</p>
<!--
<pre>   # read each line from file, split into values, and write INSERT statement
   f = File.open("people.txt", "r")
   f.each_line do |line|
       name, height = line.chomp.split("\t")
       printf "INSERT INTO people (id, name, height) VALUES(%s, %s, %s);\n",
               dbh.quote(nil), dbh.quote(name), dbh.quote(height)
   end
   f.close
</pre>
-->
<pre>   # ファイルから一行づつ読んで、値に分けて、INSERT文を書き出す。
   f = File.open("people.txt", "r")
   f.each_line do |line|
       name, height = line.chomp.split("\t")
       printf "INSERT INTO people (id, name, height) VALUES(%s, %s, %s);\n",
               dbh.quote(nil), dbh.quote(name), dbh.quote(height)
   end
   f.close
</pre>
<a name="TOC_9">
<h3>
<!--
Query Metadata
-->
メタデータの問い合わせ
</h3>
</a>
<p>
<!--
For statements that return no result set, such as <tt>INSERT</tt>
or <tt>DELETE</tt>, <tt>do</tt> returns a count of the number
of rows processed.<br>
-->
<tt>INSERT</tt>や<tt>DELETE</tt>といった結果セットを戻さないSQL文の場
合、<tt>do</tt>メソッドは処理された行数を戻します。
</p><p>
<!--
For statements that return rows, such as <tt>SELECT</tt>, you
can use the statement handle after invoking <tt>execute</tt> to
get row and column counts or information about each of the columns
in the result set:<br>
-->
<tt>SELECT</tt>といった行を戻すSQL文の場合、<tt>execute</tt>を呼んだ後
に文ハンドルを使い、結果セットの行数やカラム数、個々のカラムの情報を得
ることができます。
</p><ul>
<li>
<!--
The row and column counts are not available directly. To get the
row count, either count the rows as you fetch them, or fetch them
into a data structure and see how many elements it contains. To
get the column count, you can determine it from the number of
column names, available as <tt>sth.column_names.size</tt>.<br>
-->
行数やカラム数は直接には利用することはできません。行数を得るためには、
<tt>fetch</tt>で取り出した行をカウントするか、適当なデータ構造に入れて、
そこに要素がどれだけあるかを調べてください。カラム数はカラム名の数から
<tt>sth.column_names.size</tt>を利用して決定することができます。
</li><li>
<!--
The <tt>column_info</tt> method returns information about each
column.<br>
-->
<tt>column_info</tt>メソッドは各カラムの情報を戻します。
</li></ul>
<!--
This script shows how to obtain metadata for a query:<br>
-->
次のスクリプトは問い合わせからメタデータを得る方法を示します。
<!--
<pre>   sth = dbh.execute(query)

   puts "Query: " + query
   if sth.column_names.size == 0 then
       puts "Query has no result set"
       printf "Number of rows affected: %d\n", sth.rows
   else
       puts "Query has a result set"
       rows = sth.fetch_all
       printf "Number of rows: %d\n", rows.size
       printf "Number of columns: %d\n", sth.column_names.size
       sth.column_info.each_with_index do |info, i|
           printf "--- Column %d (%s) ---\n", i, info.name
           printf "precision:  %s\n", info.precision
           printf "scale:      %s\n", info.scale
       end
   end
   sth.finish
</pre>
-->
<pre>   sth = dbh.execute(query)

   puts "問い合わせ: " + query
   if sth.column_names.size == 0 then
       puts "問い合わせには結果セットがありません。"
       printf "影響を受けた行の数: %d\n", sth.rows
   else
       puts "問い合わせには結果セットがあります。"
       rows = sth.fetch_all
       printf "行数:     %d\n", rows.size
       printf "カラム数: %d\n", sth.column_names.size
       sth.column_info.each_with_index do |info, i|
           printf "--- カラム %d (%s) ---\n", i, info.name
           printf "精度:     %s\n", info.precision
           printf "スケール: %s\n", info.scale
       end
   end
   sth.finish
</pre>
<!--
Note: Older versions of this document stated that you can get
the row count for a <tt>SELECT</tt> result as <tt>sth.rows</tt>.
That is not supported. (It currently does happen to work for the
MySQL driver, but you should not rely on this behavior.)<br>
-->
注意事項: 古いバージョンのこの文書では、<tt>SELECT</tt>文の結果の行数
を<tt>sth.rows</tt>で得ることができると述べていましたが、これはサポー
トされていません。(現在のところ MySQL ドライバではたまたま動きますが、
この挙動は信頼しないでください。)
<a name="TOC_10">
<h2>
<!--
Methods That Take Code Blocks
-->
コードブロックつきのメソッド
</h2>
</a><br>
<p>
<!--
Some handle-creating methods may be invoked with a code block.
When executed this way, they provide the handle to the code block
as its parameter, and automatically clean up the handle when the
block terminates:<br>
-->
ハンドルを生成するメソッドのうちいくつかはコードブロック付きで呼ぶこと
ができます。ブロック付きで実行した時、ハンドルはコードブロックのパラメー
タとして渡され、ブロックの実行が終了したら自動的にハンドルが解放されま
す。
</p><ul>
<li>
<!--
<tt>DBI.connect</tt> generates a database handle, for which it
calls <tt>disconnect</tt> if necessary at the end of the block.<br>
-->
<tt>DBI.connect</tt>はデータベースハンドルを生成し、必要ならばブロック
の最後でデータベースハンドルに対して<tt>disconnect</tt>を呼びます。
</li><li>
<!--
<tt>dbh.prepare</tt> generates a statement handle, for which it
calls <tt>finish</tt> at the end of the block. Within the block,
you must invoke <tt>execute</tt> to execute the statement.<br>
-->
<tt>dbh.prepare</tt>は文ハンドルを生成し、ブロックの最後で文ハンドルに
対して<tt>finish</tt>を呼びます。ブロック内ではSQL文を実行するのに
<tt>execute</tt>を呼んでください。
</li><li>
<!--
<tt>dbh.execute</tt> is similar except you don't invoke <tt>execute</tt>
within the block; the statement handle is automatically executed.<br>
-->
<tt>dbh.execute</tt>はブロック内で<tt>execute</tt>を呼ぶ必要がないこと
以外は<tt>dbh.prepare</tt>と同じです。文ハンドルは自動的に実行されます。
</li></ul>
<!--
The following example illustrates use of a code block with each
of those handle-creating methods:<br>
-->
これらのハンドルを生成するメソッドそれぞれに対してコードブロックを使っ
た例です。
<!--
<pre>   # connect can take a code block, passes the database handle to it,
   # and automatically disconnects the handle at the end of the block

   DBI.connect("dbi:Mysql:test:localhost", "testuser", "testpass") do |dbh|

       # prepare can take a code block, passes the statement handle
       # to it, and automatically calls finish at the end of the block

       dbh.prepare("SHOW DATABASES") do |sth|
           sth.execute
           puts "Databases: " + sth.fetch_all.join(", ")
       end

       # execute can take a code block, passes the statement handle
       # to it, and automatically calls finish at the end of the block

       dbh.execute("SHOW DATABASES") do |sth|
           puts "Databases: " + sth.fetch_all.join(", ")
       end
   end
</pre>
-->
<pre>   # connectはコードブロックをとり、データベースハンドルをブロックに渡します。
   # ブロックの最後では自動的にハンドルを切断します。

   DBI.connect("dbi:Mysql:test:localhost", "testuser", "testpass") do |dbh|

       # prepareはコードブロックをとり、文ハンドルをブロックに渡します。
       # ブロックの最後では自動的にfinishを呼びます。

       dbh.prepare("SHOW DATABASES") do |sth|
           sth.execute
           puts "Databases: " + sth.fetch_all.join(", ")
       end

       # executeはコードブロックをとり、文ハンドルをブロックに渡します。
       # ブロックの最後では自動的にfinishを呼びます。

       dbh.execute("SHOW DATABASES") do |sth|
           puts "Databases: " + sth.fetch_all.join(", ")
       end
   end
</pre>
<!--
There is also a <tt>transaction</tt> method that takes a code
block. It is described in "Transaction Support."<br>
-->
他にコードブロックを取る<tt>transaction</tt>メソッドがあります。
使い方は「トランザクションサポート」で説明されます。
<a name="TOC_11">
<h2>
<!--
More on Connecting to the Server
-->
サーバへの接続の補足
</h2>
</a><br>
<p>
<!--
The <i>simple.rb</i> script shown earlier connects to the server
using the DBI <tt>connect</tt> method as follows:<br>
-->
以前、例に出した<i>simple.rb</i>スクリプトはサーバへ接続するのに以下の
ようにDBIの<tt>connect</tt>メソッドを用いています。
</p><pre>   dbh = DBI.connect("dbi:Mysql:test:localhost", "testuser", "testpass")
</pre>
<!--
The first argument to <tt>connect</tt> is the data source name
(DSN); it identifies the type of connection to make. The other
two arguments are the username and password of your MySQL account.<br>
-->
<tt>connect</tt>の第一引数はデータソース名(DSN, data source name)で、
作成しようとする接続の種類を区別します。残りの２つの引数はMySQLアカウ
ントのユーザ名とパスワードです。
<p>
<!--
The DSN can be given in any of the following formats:<br>
-->
DSN は以下の書式ならどれでも受け付けます。
</p><pre>   dbi:<i>driver_name</i>
   dbi:<i>driver_name</i>:<i>db_name</i>:<i>host_name</i>
   dbi:<i>driver_name</i>:<i>key=val</i>;<i>key=val</i>...
</pre>
<!--
The DSN always begins with <tt>dbi</tt> or <tt>DBI</tt> (in lowercase
or uppercase, but not in mixed case) and the driver name. For
MySQL, the driver name is <tt>Mysql</tt>, and it's best to use
exactly that capitalization. (There is some indication in the
DBI specification that lettercase of the driver name should not
matter, but that is not always true up through DBI versions as
recent as 0.0.18.) For other drivers, you'll need to use the appropriate
driver name.<br>
-->
DSNは常に<tt>dbi</tt>もしくは<tt>DBI</tt>で始まります。(すべて大文字か
すべて小文字かのどちらかです。両者の混在は受け付けません。) 続けて、ド
ライバ名となります。MySQLの場合はドライバ名は<tt>Mysql</tt>です。正確
に先頭のみを大文字にして用いたほうが良いでしょう。(DBI仕様書にはドライ
バ名は大文字小文字どちらでも良いと指示されてますが、最新の 0.0.18 でも
それが常に真とはかぎりません。) 他のドライバを使用する場合は、適切なド
ライバ名を使う必要があります。
<p>
<!--
<tt>dbi</tt> (or <tt>DBI</tt>) and the driver name must always
be given in the DSN. If nothing follows the driver name, the driver
may (I think) attempt to connect using a default database and
host name. The MySQL driver tries to require a database name to
be specified, so the first format cannot be used for MySQL programming
with DBI; you must use one of the other formats. The second format
requires two values, a database name and hostname separated by
a colon. The third format allows a list of parameter assignments
to be specified in <tt><i>param</i></tt><tt>=</tt><tt><i>value</i></tt>
format separated by semicolons. The following DSNs are all equivalent:<br>
-->
<tt>dbi</tt>(もしくは<tt>DBI</tt>)とドライバ名は常にDSNに与える必要が
あります。ドライバ名に続けて何も指定されてないときは、ドライバは(おそ
らく)デフォルトのデータベースとホスト名を使って接続しようとします。
MySQLドライバの場合はデータベース名を指定する必要があるので、DBIを使っ
たMySQLプログラミングでは第一の書式は使えません。他の書式を使ってくだ
さい。第二の書式は２つの値を要求します。コロンで区切られたデータベース
名とホスト名です。第三の書式はセミコロンで区切られた
<tt>param=value</tt>の形式でパラメータの指定を行います。次のDSNはすべ
て同じ意味をもちます。
</p><pre>   dbi:Mysql:test:localhost
   dbi:Mysql:host=localhost;database=test
   dbi:Mysql:database=test;host=localhost
</pre>
<!--
The DSN syntax that uses <tt><i>param</i></tt><tt>=</tt><tt><i>value</i></tt>
format is the most flexible because it allows the parameters to
be specified in any order. It also allows for the possibility
driver-specific parameters, which means that drivers can be extensible
in the connection parameters they accept. For MySQL, allowable
additional parameters in addition to <tt>host</tt> and <tt>database</tt>
are <tt>port</tt>, <tt>socket</tt>, and <tt>flag</tt>. (These
map to the corresponding parameters of the <tt>real_connect</tt>
method of the Ruby MySQL module that underlies <tt>DBD::Mysql</tt>.)<br>
-->

<tt>param=value</tt>の形式を使ったDSNの構文は最も柔軟です。というのも、
パラメータを任意の順番で指定できるからです。また、ドライバ固有のパラメー
タを指定できる可能性もあります。ドライバは受け付けることのできる接続パ
ラメータを拡張することができるからです。MySQLの場合は、<tt>host</tt>と
<tt>database</tt>の他の追加のパラメータは<tt>port</tt>、
<tt>socket</tt>、<tt>flag</tt>です。(これらのパラメータは、
<tt>DBD::Mysql</tt>の下にある Ruby MySQL モジュールの
<tt>real_connect</tt>メソッドの対応するパラメータに渡されます。)

<a name="TOC_12">
<h2>
<!--
Error Handling and Debugging
-->
エラー処理とデバッグ
</h2>
</a>
<p>
<!--
If a DBI method fails, DBI raises an exception. DBI methods may
raise any of several types of exception, but for database-related
operations, the relevant exception class is <tt>DatabaseError</tt>.
Exception objects of this class have three attributes named <tt>err</tt>,
<tt>errstr</tt>, and <tt>state</tt>. The DBI documentation isn't
specific on the meaning of these attributes, but they appear to
represent the error number, a descriptive error string, and some
kind of "standard" error code. The MySQL driver at the
moment supplies only the error string, although it's easy to patch
the driver to supply the error number as well. Assuming that both
values are available, you can obtain them when an exception occurs
as follows:<br>
-->
DBIメソッドが失敗するとDBIは例外を上げます。DBIメソッドはどんな例外で
も上げる可能性はありますが、データベースに関する操作に対しては、それに
関係する例外クラス、<tt>DatabaseError</tt>があります。このクラスの例外
オブジェクトには<tt>err</tt>、<tt>errstr</tt>、<tt>state</tt>という３
つの属性があります。DBIドキュメントはこれらの属性の意味を特定してはい
ませんが、それぞれエラー番号、説明的なエラー文字列、そしてある種の「標
準」エラーコードをあらわしているように見えます。MySQLドライバは現時点
ではエラー文字列のみを提供しています。しかし、エラー番号を同様に戻すよ
うにするドライバへパッチは簡単なことです。両方の値が利用可能と仮定する
と、例外が起こったときにこれらの値を得るには次のようにします。
</p><pre>   rescue DBI::DatabaseError =&gt; e
       puts "An error occurred"
       puts "Error code: #{e.err}"
       puts "Error message: #{e.errstr}"
</pre>
<!--
To get debugging information on what your script is doing as it
executes, you can enable tracing. To do this, you must first load
the <tt>dbi/trace</tt> module:<br>
-->

実行しようとするスクリプトが何をしているのかデバッグ情報を実行の順序ど
おりに得るには、トレース可能な状態にしてください。そうするには、まず最
初に<tt>dbi/trace</tt>モジュールを読み込みます。
<pre>   require "dbi/trace"
</pre>
<!--
The <tt>dbi/trace</tt> module is not loaded automatically by the
<tt>dbi</tt> module because it is dependent on version 0.3.3 or
newer of the AspectR module, which may not be present on your
machine.<br>
-->
<tt>dbi/trace</tt>は<tt>dbi</tt>モジュールによって自動的には読み込まれ
ません。というのも、AspectRモジュールのバージョン0.3.3以降に依存するか
らです。AspectRはあなたのマシンに存在しないかもしれません。
<p>
<!--
The <tt>dbi/trace</tt> module provides a <tt>trace</tt> method
that controls the trace mode and output destination:<br>
-->

<tt>dbi/trace</tt>モジュールは<tt>trace</tt>メソッドを提供します。
<tt>trace</tt>メソッドでトレースのモードと出力先を設定をします。
</p><pre>   trace(<i>mode</i>, <i>destination</i>)
</pre>
<!--
The <tt><i>mode</i></tt> value may be 0 (off), 1, 2, or 3, and
the <tt><i>destination</i></tt> should be an <tt>IO</tt> object.
The default values are 2 and <tt>STDERR</tt>, respectively.<br>
-->
<tt><i>mode</i></tt>は 0(off)、1、 2、3 の値をとります。
<tt><i>destination</i></tt>は<tt>IO</tt>オブジェクトでないといけません。
デフォルト値は<tt><i>mode</i></tt>は2で、<tt><i>destination</i></tt>は
<tt>STDERR</tt>です。
<p>
<!--
<tt>trace</tt> may be invoked as a class method to affect all
subsequently created handles, or as an object method for individual
driver, database, or statement handles. When invoked as an object
method, any other objects subsequently derived from that object
also inherit the trace setting. For example, if you enable tracing
on a database handle, statement handles created from it are given
the same trace setting.<br>
-->
<tt>trace</tt>はクラスメソッドとして呼び出されると、続いて作成されるす
べてのハンドルに対して影響します。または、ドライバ、データベースハンド
ル、文ハンドルに対して個々にインスタンスメソッドとして呼び出すこともで
きます。インスタンスメソッドとして呼ばれると、そのオブジェクトに由来す
るすべてのオブジェクトに対してもトレースの設定が引き継がれます。例えば、
データベースハンドルに対してトレースを有効にすると、そこから作成された
文ハンドルのトレースの設定は同じになります。
<a name="TOC_13">
<h2>
<!--
Transaction Support
-->
トランザクション・サポート
</h2>
</a><br>
</p><p>
<!--
DBI provides a transaction abstraction. However, availability
of the abstraction depends on transaction support in your database
engine, and on a DBD-level implementation of the abstraction in
your driver. For the MySQL driver, this abstraction is not functional
prior to DBI 0.0.19, so you must perform transactions by explicitly
using statements that control the auto-commit level, commits,
and rollbacks. For example:<br>
-->
トランザクションの使用方法はデータベースによって異なりますが、DBIはト
ランザクションを抽象化して、同じ手順で使える機能を提供します。しかし、
抽象化が使えるかどうかは使用しているデータベースエンジンがトランザクショ
ンをサポートしているかどうか、さらには使用するドライバがDBIレベルの抽
象化を実装しているかどうかに依存します。MySQLドライバの場合は、この抽
象化は DBI 0.0.19 より前では機能していません。したがって、トランザクショ
ンを実行するには明示的にSQL文を使って自動コミットレベル、コミット、ロー
ルバックを制御しないといけません。例えば以下のようにです。
</p><pre>   dbh.do("SET AUTOCOMMIT=0")
   dbh.do("BEGIN")
<i>   ... statements that make up the transaction ...</i>
   dbh.do("COMMIT")
</pre>
<!--
For DBI 0.0.19 and up, you can use the transaction abstraction
with MySQL. One aspect of the abstraction allows the auto-commit
level to be set by assigning to the database handle <tt>AutoCommit</tt>
attribute:<br>
-->
DBI 0.0.19 以降では、MySQL でトランザクションの抽象化を利用できます。
抽象化の側面のひとつに、自動コミットのレベルをデータベースハンドルの
<tt>AutoCommit</tt>属性の指定で設定できることにあります。
<pre>   dbh['AutoCommit'] = true
   dbh['AutoCommit'] = false
</pre>
<!--
While auto-commit is disabled (set to <tt>false</tt>), you can
perform transactions two ways. The following examples illustrate
the two approaches, using an <tt>account</tt> table for which
funds are transferred from one person to another.<br>
-->
自動コミットが無効な間は(<tt>false</tt>を設定)、トランザクションは２つ
の方法で制御できます。次の例でその２つのアプローチを説明します。例とし
て<tt>account</tt>テーブルを用い、資金をひとりの人から別の人にわたしま
す。
<ul>
<li>
<!--
The first approach uses DBI's <tt>commit</tt> and <tt>rollback</tt>
methods to explicitly commit or cancel the transaction:<br>
-->
最初の例では、DBIの<tt>commit</tt>メソッドと<tt>rollback</tt>メソッド
を使用してトランザクションを明示的にコミットまたはロールバックします。
<pre>   dbh['AutoCommit'] = false
   begin
       dbh.do("UPDATE account SET balance = balance - 50
               WHERE name = 'bill'")
       dbh.do("UPDATE account SET balance = balance + 50
               WHERE name = 'bob'")
       dbh.commit
   rescue
       puts "transaction failed"
       dbh.rollback
   end
</pre>
</li><li>
<!--
The second approach uses the <tt>transaction</tt> method. This
is simpler, because it takes a code block containing the statements
that make up the transaction. The <tt>transaction</tt> method
executes the block, then invokes <tt>commit</tt> or <tt>rollback</tt>
automatically, depending on whether the block succeeds or fails:<br>
-->
二番目のアプローチでは<tt>transaction</tt>メソッドを使用します。トラン
ザクションとしてなりたつSQL文を含むコードブロックを持つのは同様です。
<tt>transaction</tt>メソッドはブロックを実行して、ブロックの実行が成功
か失敗かによって自動的に<tt>commit</tt>または<tt>rollback</tt>を呼び出
します。
<pre>   dbh['AutoCommit'] = false
   dbh.transaction do |dbh|
       dbh.do("UPDATE account SET balance = balance - 50
               WHERE name = 'bill'")
       dbh.do("UPDATE account SET balance = balance + 50
               WHERE name = 'bob'")
   end
</pre>
</li></ul>
<a name="TOC_14">
<h2>
<!--
Accessing Driver-Specific Capabilities
-->
ドライバ固有の機能を呼び出す。
</h2>
</a>
<p>
<!--
DBI provides a <tt>func</tt> method that drivers can use to make
database-dependent features available. For example, the MySQL
C API provides a <tt>mysql_insert_id()</tt> function that returns
the most recent <tt>AUTO_INCREMENT</tt> value for a connection.
The Ruby MySQL module provides a binding to this function via
its <tt>insert_id</tt> database handle method, and <tt>DBD::Mysql</tt>
in turn provides access to <tt>insert_id</tt> via the DBI <tt>func</tt>
mechanism.<br>
-->
DBIはデータベースに依存する特別な機能を利用するための<tt>func</tt>
メソッドを提供してます。例えば MySQL の C API には、使用中のコネクショ
ンでの最新の<tt>AUTO_INCREMENT</tt>の値を戻すmysql_insert_id()関数があ
ります。Ruby MySQL モジュールはデータベースハンドルのメソッド<tt>insert_id</tt>
を経由してこの関数を呼び出します。また、DBD::Mysql は DBI の
<tt>func</tt>メカニズムを経由して<tt>insert_id</tt>にアクセスします。
</p><p>
<!--
The first argument to <tt>func</tt> is the name of the database-specific
method you want to use; the following arguments are those required
by the method, if any. The <tt>insert_id</tt> method requires
no additional arguments, so to access the most recent <tt>AUTO_INCREMENT</tt>
value, do this:<br>
-->
<tt>func</tt>の第一引数にはデータベース固有のメソッドの名前を指定しま
す。残りの引数には必要ならばデータベース固有のメソッドが必要とする値を
わたします。<tt>insert_id</tt>メソッドは追加の引数を必要とはしません。
したがって<tt>AUTO_INCREMENT</tt>の最新の値を得るには次のようにします。
</p><pre>   dbh.do("INSERT INTO people (name,height) VALUES('Mike',70.5)")
   id = dbh.func(:insert_id)
   puts "ID for new record is: " + id.to_s
</pre>
<!--
The other driver-specific methods supported by <tt>DBD::Mysql</tt>
are:<br>
-->
<tt>DBD::Mysql</tt>によりサポートされるその他のドライバ固有のメソッド
は以下のとおりです。

<!--
<pre>   dbh.func(:createdb, <i>db_name</i>) Create a new database
   dbh.func(:dropdb, <i>db_name</i>)   Drop a database
   dbh.func(:reload)            Perform a reload operation
   dbh.func(:shutdown)          Shut down the server
</pre>
-->
<pre>   dbh.func(:createdb, <i>db_name</i>) 新しいデータベースを作成する。
   dbh.func(:dropdb, <i>db_name</i>)   データベースを削除する。
   dbh.func(:reload)            リロード操作を実行する。
   dbh.func(:shutdown)          サーバをシャットダウンする。
</pre>

<!--
Note that <tt>createdb</tt> and <tt>dropdb</tt> are unavailable
unless your MySQL client library comes from a version older than
MySQL 4. Those methods correspond to deprecated functions that
the Ruby MySQL module does not support as of MySQL 4.<br>
-->
あなたの使用しているMySQLクライアントライブラリのバージョンが MySQL 4
以上の場合、<tt>createdb</tt>と<tt>dropdb</tt>が使用できないことに注意
してください。これらのメソッドは MySQL 4 より Ruby MySQL モジュールで
使用してはいけない関数(deprecated functions)となっています。

<p>
<!--
In some cases, use of a driver-specific function may offer specific
advantages, even if there is another way to accomplish the same
thing. For example, the value returned by the <tt>insert_id</tt>
function of <tt>DBD::Mysql</tt> can be obtained by issuing a <tt>SELECT</tt>
<tt>LAST_INSERT_ID()</tt> query. Both return the same value in
most cases. However, the <tt>insert_id</tt> function is more efficient
because it returns a value that is stored on the client side and
can be accessed without issuing another query. This efficiency
benefit comes at the cost of greater care in how you use the function.
Its value is reset for each query executed, so you must access
it after issuing the query that generates an <tt>AUTO_INCREMENT</tt>
value but before issuing any other query. By contrast, the value
of <tt>LAST_INSERT_ID()</tt> is stored on the server side and
is more persistent; it is not reset by other queries except those
that also generate <tt>AUTO_INCREMENT</tt> values.<br>
-->
同じことを実現するのにドライバ固有の機能を使用した場合と通常のSQLを発
行して実現する方法の２つがある場合、ドライバ固有の機能を使用したほうが
効率的である場合があります。例えば、
<tt>SELECT</tt> <tt>LAST_INSERT_ID()</tt> を発行した結果は
<tt>DBD::Mysql</tt>の<tt>insert_id</tt>関数の戻り値でも得ることができ
ます。両者ほほとんどの場合同じ結果を戻します。しかし<tt>insert_id</tt>
関数のほうがより効率的です。というのも<tt>insert_id</tt>は、問い合わせ
を発行することなしにクライアント側に保持された値を戻すからです。
効率上の利点を追及するには、注意深く関数呼び出しを行う必要があります。
<tt>insert_id</tt>の値はそれぞれの問い合せの実行毎にリセット
されます。そのため、<tt>AUTO_INCREMENT</tt>値を生成する問い合わせを発
行した後、他の問い合わせを発行する前にアクセスしないといけません。対照
的に<tt>LAST_INSERT_ID()</tt>の値はサーバ側にもっと長い時間保持されま
す。<tt>AUTO_INCREMENT</tt>値を生成する問い合わせが発行されない限りリ
セットされることはありません。

<a name="TOC_15">
<h2>
<!-- Other DBI Goodies -->
その他の便利な機能
</h2>
</a>
</p><p>
<!--
The <tt>DBI::Utils</tt> module includes a few interesting methods:<br>
-->

DBI::Utilsモジュールには興味深いメソッドがいくつかあります。<br>
</p><ul>
<li>
<!--
<tt>DBI::Utils::measure</tt> takes a code block and measures how
long it takes to execute the code within the block. You can use
this method to measure the wallclock time for execution of a statement
as follows:<br>
-->

DBI::Utils::measure はブロックをとり、ブロック内でどれぐらい実行時間が
かかったかを計測します。このメソッドを利用すると以下のように問合せを発
行したときの経過時間を測定できます。<br>

<pre>   elapsed = DBI::Utils::measure do
       dbh.do(query)
   end
   puts "Query: " + query
   puts "Elapsed time: " + elapsed.to_s
</pre>
</li><li>
<!--
The <tt>DBI::Utils::TableFormatter</tt> module has an <tt>ascii</tt>
method for displaying the contents of a result set. The first
argument is an array of column names, and the second is an array
of row objects. To display the contents of the <tt>people</tt>
table, do this:<br>
-->

<tt>DBI::Utils::TableFormatter</tt>モジュールには、結果セットの内容を
表示する<tt>ascii</tt>メソッドがあります。第一引数はカラム名の配列で、
第二引数は行オブジェクトの配列です。<tt>people</tt>テーブルの中身を表
示するには以下のようにしてください。<br>
<pre>   sth = dbh.execute("SELECT * FROM people")
   rows = sth.fetch_all
   col_names = sth.column_names
   sth.finish
   DBI::Utils::TableFormatter.ascii(col_names, rows)
</pre>
<!--
The resulting output is:<br>
-->
結果の出力は以下のようになります。<br>
<pre>   +----+---------+--------+
   | id | name    | height |
   +----+---------+--------+
   | 1  | Wanda   | 62.5   |
   | 2  | Robert  | 75.0   |
   | 3  | Phillip | 71.5   |
   | 4  | Sarah   | 68.0   |
   +----+---------+--------+
</pre>
</li><li>
<!--
The <tt>DBI::Utils::XMLFormatter</tt> module has <tt>row</tt>
and <tt>table</tt> methods for displaying individual result set
rows or an entire result set as XML. This makes it easy to generate
XML output from query results. The following example demonstrates
the <tt>table</tt> method:<br>
-->

<tt>DBI::Utils::XMLFormatter</tt>モジュールには結果セットの個々の行を
XMLで表示するための<tt>row</tt>メソッドと、結果セット全体をXMLで表示す
るための<tt>table</tt>メソッドがあります。このモジュールを使用すると、
問合せの結果から XML 出力を簡単に作成することができます。以下は
<tt>table</tt>メソッドの例です。
<pre>   DBI::Utils::XMLFormatter.table(dbh.select_all("SELECT * FROM people"))
</pre>
<!--
The resulting output is:<br>
-->
結果の出力は以下のようになります。<br>
<pre>   &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
   &lt;rows&gt;
   &lt;row&gt;
     &lt;id&gt;1&lt;/id&gt;
     &lt;name&gt;Wanda&lt;/name&gt;
     &lt;height&gt;62.5&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;2&lt;/id&gt;
     &lt;name&gt;Robert&lt;/name&gt;
     &lt;height&gt;75.0&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;3&lt;/id&gt;
     &lt;name&gt;Phillip&lt;/name&gt;
     &lt;height&gt;71.5&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;4&lt;/id&gt;
     &lt;name&gt;Sarah&lt;/name&gt;
     &lt;height&gt;68.0&lt;/height&gt;
   &lt;/row&gt;
   &lt;/rows&gt;
</pre>
</li></ul>
<!--
The <tt>ascii</tt> and <tt>table</tt> methods support a number
of optional arguments that provide greater control over the output
format and destination. See the module source code for more information.<br>
-->

<tt>ascii</tt>メソッドと<tt>table</tt>メソッドにはオプションの引数がい
ろいろあります。オプションによって出力フォーマットや出力先を細かく制御
できます。オプションの情報を得るには、モジュールのソースコードを見てく
ださい。<br>

<a name="TOC_16">
<h2>
<!-- Resources -->
参考情報
</h2>
</a><br>
<p>
<!--
The scripts that are used for examples in this article can be
downloaded from the following location:
-->

この記事の例で使用したスクリプトは以下の場所よりダウンロードできます。<br>
</p><pre>   <a href="http://www.kitebird.com/articles/">http://www.kitebird.com/articles/
</a>
</pre>
<!--
That location also provides access to an article, "Using
the Ruby MySQL Module," that discusses the module that forms
the basis for <tt>DBD::Mysql</tt>, the DBD-level MySQL driver
for DBI.
-->

ここには "Using the Ruby MySQL Module(英語)" という記事があり、
DBD::Mysql(DBD層のMySQLドライバ)の土台となっているRuby MySQLモジュール
の説明をしてます。
<br>
<p>
<!--
You may find the following additional resources helpful for using
Ruby DBI:
-->

Ruby DBI を使用するのに役立つ情報は以下の場所より見付けられます。
<br>
</p><ul>
<li>
<!--
You can get the Ruby DBI module and specification documents from
the DBI SourceForge site:
-->

DBI SourceForge サイトより Ruby DBI モジュールと仕様書を得ることができます。<br>
<pre>   <a href="http://ruby-dbi.sourceforge.net/">http://ruby-dbi.sourceforge.net/
</a>
</pre>
</li><li>
<!--
The AspectR Ruby module must be installed if you want to use the
<tt>dbi/trace</tt> module that provides DBI execution tracing.
You can get AspectR at its SourceForge site:
-->

DBI の実行トレースをとるために dbi/trace モジュールを使いたい場合は AspectR Ruby
モジュールをインストールしてください。AspectR は SourceForge より得ることができます。<br>
<pre>   <a href="http://aspectr.sourceforge.net/">http://aspectr.sourceforge.net/
</a>
</pre>
</li><li>
<!--
The Ruby home page provides general information about Ruby itself:
-->

Rubyホームページでは Ruby そのものに関する一般的な情報を提供してます。<br>
<pre>   <a href="http://www.ruby-lang.org/">http://www.ruby-lang.org/
</a>
</pre>
</li><li>
<!--
MySQL may be obtained at:
-->

MySQL は次の場所から取得できます。<br>
<pre>   <a href="http://www.mysql.com/">http://www.mysql.com/
</a>
</pre>
</li></ul>
</body></html>
